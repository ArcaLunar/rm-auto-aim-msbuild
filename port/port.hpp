#ifndef __PORT_HPP__
#define __PORT_HPP__

#include "boost/asio.hpp"
#include "circular_buffer.hpp"
#include "structs.hpp"
#include <array>
#include <boost/asio/io_context.hpp>
#include <boost/asio/io_service.hpp>
#include <boost/asio/steady_timer.hpp>
#include <chrono>
#include <deque>
#include <memory>
#include <vector>

class SerialPort : public std::enable_shared_from_this<SerialPort> {
    static constexpr size_t kSendMsgSize  = sizeof(VisionPLCSendMsg);
    static constexpr size_t kRecvMsgSize  = sizeof(VisionPLCRecvMsg);
    static constexpr size_t kRecvMsgCount = 20; // maximum of 20 cached messages
    static constexpr long long kTimeout = 1000; // 1s timeout
    using RawMessage    = std::array<u8, kRecvMsgSize>;

  public:
    SerialPort(std::string path = "../config/port.toml");

    void open_port();
    void close_port();
    void send_message();

    /**
     * @brief This `read_raw()` reads raw data from the serial port. Should run as a thread.
     */
    void read_raw();
    /**
     * @brief Continuously consume raw messages from the circular buffer (generated by `read_raw()`) and process them. Then push them into circular buffer for VisionPLCRecvMsg.
     * 
     */
    void process_raw();

    /**
     * @brief Periodically check if the port is still connected. If not, try to reconnect.
     * 
     */
    void check_reconnect();

  private:
    boost::asio::io_context ctx{};
    boost::asio::serial_port port;
    boost::asio::steady_timer timer;

    size_t port_index{0};
    std::string port_name;                 // current port name
    std::vector<std::string> port_options; // alternative port options

    PortConfig cfg;
    bool port_ok{false};

    u8 updated{0};
    std::chrono::steady_clock::time_point last_recv;

    CircularBuffer<RawMessage> raw_cbuffer;
    CircularBuffer<VisionPLCRecvMsg> recv_cbuffer;

    // 用于缓存待发送的数据
    std::deque<VisionPLCSendMsg> send_queue;

  protected:
    bool verify() {}
};

#endif