#ifndef __PORT_HPP__
#define __PORT_HPP__

#include "boost/asio.hpp"
#include "circular_buffer.hpp"
#include "structs.hpp"
#include <array>
#include <boost/asio/io_context.hpp>
#include <boost/asio/io_service.hpp>
#include <boost/asio/steady_timer.hpp>
#include <chrono>
#include <memory>
#include <vector>

// Vector of alternative ports to try when connecting
const std::vector<std::string> kAlternativePorts
    = {"/dev/ttyACM0", "/dev/ttyACM1", "/dev/ttyACM2", "/dev/ttyUSB0", "/dev/ttyUSB1", "/dev/ttyUSB2"};

class SerialPort : public std::enable_shared_from_this<SerialPort> {
    static constexpr size_t kSendMsgSize  = sizeof(VisionPLCSendMsg);
    static constexpr size_t kRecvMsgSize  = sizeof(VisionPLCRecvMsg);
    static constexpr size_t kRecvMsgCount = 20;   // maximum of 20 cached messages
    static constexpr long long kTimeout   = 1000; // 1s timeout
    using RawMessage                      = std::array<u8, kRecvMsgSize>;

  public:
    SerialPort(std::string path = "../config/port.toml");
    ~SerialPort() { close_port(); }

    void open_port();
    void close_port();

    /**
     * @brief Sends the provided message over the serial port
     *
     * @param payload The message to send
     * @return bool True if successful, false otherwise
     */
    bool send_message(const VisionPLCSendMsg &payload);

    /**
     * @brief This `read_raw()` reads raw data from the serial port. Should run as a thread.
     */
    void read_raw();

    /**
     * @brief Continuously consume raw messages from the circular buffer (generated by `read_raw()`) and process them.
     * Then push them into circular buffer for VisionPLCRecvMsg.
     *
     */
    void process_raw();

    /**
     * @brief Periodically check if the port is still connected. If not, try to reconnect.
     *
     */
    void check_reconnect();

    /**
     * @brief Just to test the sending of messages. Should run as a thread.
     *
     */
    void test_send();

    /**
     * @brief Check if the port is currently operational
     *
     * @return bool True if port is open and ready
     */
    bool is_port_ok() const { return port_ok; }

  private:
    boost::asio::io_context ctx{};
    boost::asio::serial_port port;
    boost::asio::steady_timer timer;

    size_t port_index{0};
    std::string port_name;                 // current port name
    std::vector<std::string> port_options; // alternative port options

    PortConfig cfg;
    bool port_ok{false};

    u8 updated{0};
    std::chrono::steady_clock::time_point last_recv;

    CircularBuffer<RawMessage> raw_cbuffer;
    CircularBuffer<VisionPLCRecvMsg> recv_cbuffer;

    // Used to buffer outgoing data
    std::array<u8, kSendMsgSize> send_buffer;

  protected:
    /**
     * @brief Verify if a raw message follows the expected protocol format
     *
     * @param msg The raw message to verify
     * @return bool True if the message passes verification
     */
    bool verify(const RawMessage &msg);
};

#endif